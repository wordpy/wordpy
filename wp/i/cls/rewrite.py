# Rewrite API: WP_Rewrite class
#Package WordPress @subpackage Rewrite

import wp.conf     as WpC
import wp.i.option as WiO
import pyx.php     as Php
array = Php.array


class WP_Rewrite(Php.stdClass):
  ''' Core class used to implement a rewrite component API.
  The WordPress Rewrite class writes the rewrite module rules to the .htaccess
  file. It also handles parsing the request to get the correct setup for the
  WordPress Query class.
  The Rewrite along with WP class function as a front controller for WordPress.
  You can add rules to trigger your page view and processing using this
  component. The full functionality of a front controller does not exist,
  meaning you can't define how the template files load based on the rewrite
  rules.
  '''
  def __init__(self):
    ''' Constructor - Calls init(), which runs setup.
    @access public
    Inherited classes no long need to define 'self._obj=array()' in __init__()
    '''
    # Permalink structure for posts.
    # @var string
    #self.permalink_structure

    # Whether to add trailing slashes.
    # @var bool
    #self.use_trailing_slashes

    # Base for the author permalink structure (ex.com/$author_base/authorname)
    # @access private
    # @var string
    self.author_base = 'author'

    # Permalink structure for author archives.
    # @access private
    # @var string
    #self.author_structure

    # Permalink structure for date archives.
    # @access private
    # @var string
    #self.date_structure

    # Permalink structure for pages.
    # @access private
    # @var string
    #self.page_structure

    # Base of the search permalink structure (example.com/$search_base/query).
    # @access private
    # @var string
    self.search_base = 'search'

    # Permalink structure for searches.
    # @access private
    # @var string
    #self.search_structure

    # Comments permalink base.
    # @access private
    # @var string
    self.comments_base = 'comments'

    # Pagination permalink base.
    # @var string
    self.pagination_base = 'page'

    # Comments pagination permalink base.
    # @access private
    # @var string
    self.comments_pagination_base = 'comment-page'

    # Feed permalink base.
    # @access private
    # @var string
    self.feed_base = 'feed'

    # Comments feed permalink structure.
    # @access private
    # @var string
    #self.comment_feed_structure

    # Feed request permalink structure.
    # @access private
    # @var string
    #self.feed_structure

    # The static portion of the post permalink structure.
    # If the permalink structure is "/archive/%post_id%" then the front
    # is "/archive/". If the permalink structure is "/%year%/%postname%/"
    # then the front is "/".
    # @access public
    # @var string
    # @see WP_Rewrite::init()
    #self.front

    # The prefix for all permalink structures.
    # If PATHINFO/index permalinks are in use then the root is the value of
    # `WP_Rewrite::$index` with a trailing slash appended. Otherwise the root
    # will be empty.
    # @access public
    # @var string
    # @see WP_Rewrite::init()
    # @see WP_Rewrite::using_index_permalinks()
    self.root = ''

    # The name of the index file which is the entry point to all requests.
    # @access public
    # @var string
    self.index = 'index.php'

    # Variable name to use for regex matches in the rewritten query.
    # @access private
    # @var string
    self.matches = ''

    # Rewrite rules to match against the request to find the redirect or query.
    # @access private
    # @var array
    #self.rules

    # Additional rules added external to the rewrite class.
    # Those not generated by the class, see add_rewrite_rule().
    # @access private
    # @var array
    self.extra_rules = array()

    # Additional rules that belong at the beginning to match first.
    # Those not generated by the class, see add_rewrite_rule().
    # @access private
    # @var array
    self.extra_rules_top = array()

    # Rules that don't redirect to WordPress' index.php.
    # These rules are written to the mod_rewrite portion of the .htaccess,
    # and are added by add_external_rule().
    # @access private
    # @var array
    self.non_wp_rules = array()

    # Extra permalink structures, e.g. categories, added by add_permastruct().
    # @access private
    # @var array
    self.extra_permastructs = array()

    # Endpoints (like /trackback/) added by add_rewrite_endpoint().
    # @access private
    # @var array
    #self.endpoints

    # Whether to write every mod_rewrite rule for WordPress into the .htaccess file.
    # This is off by default, turning it on might print a lot of rewrite rules
    # to the .htaccess file.
    # @access public
    # @var bool
    # @see WP_Rewrite::mod_rewrite_rules()
    self.use_verbose_rules = False

    # Could post permalinks be confused with those of pages?
    # If the first rewrite tag in the post permalink structure is one that could
    # also match a page name (e.g. %postname% or %author%) then this flag is
    # set to True. Prior to WordPress 3.3 this flag indicated that every page
    # would have a set of rules added to the top of the rewrite rules array.
    # Now it tells WP::parse_request() to check if a URL matching the page
    # permastruct is actually a page before accepting it.
    # @access public
    # @var bool
    # @see WP_Rewrite::init()
    self.use_verbose_page_rules = True

    # Rewrite tags that can be used in permalink structures.
    # These are translated into the regular expressions stored in
    # `WP_Rewrite::$rewritereplace` and are rewritten to the query
    # variables listed in WP_Rewrite::$queryreplace.
    # Additional tags can be added with add_rewrite_tag().
    # @access private
    # @var array
    self.rewritecode = array(
      '%year%',
      '%monthnum%',
      '%day%',
      '%hour%',
      '%minute%',
      '%second%',
      '%postname%',
      '%post_id%',
      '%author%',
      '%pagename%',
      '%search%'
    )

    # Regular expressions to be substituted into rewrite rules in place
    # of rewrite tags, see WP_Rewrite::$rewritecode.
    # @access private
    # @var array
    self.rewritereplace = array(
      '([0-9]{4})',
      '([0-9]{1,2})',
      '([0-9]{1,2})',
      '([0-9]{1,2})',
      '([0-9]{1,2})',
      '([0-9]{1,2})',
      '([^/]+)',
      '([0-9]+)',
      '([^/]+)',
      '([^/]+?)',
      '(.+)'
    )

    # Query variables that rewrite tags map to, see WP_Rewrite::$rewritecode.
    # @access private
    # @var array
    self.queryreplace = array(
      'year=',
      'monthnum=',
      'day=',
      'hour=',
      'minute=',
      'second=',
      'name=',
      'p=',
      'author_name=',
      'pagename=',
      's='
    )
    # Supported default feeds.
    # @var array
    self.feeds = array( 'feed', 'rdf', 'rss', 'rss2', 'atom' )

    self.init()

  def using_permalinks(self):
    ''' Determines whether permalinks are being used.
    This can be either rewrite module or permalink in the HTTP query string.
    @access public
    @return bool True, if permalinks are enabled.
    '''
    return not Php.empty(self, 'permalink_structure')

  def using_index_permalinks(self):
    ''' Determines whether permalinks are being used and rewrite module is not enabled.
    Means that permalink links are enabled and index.php is in the URL.
    @access public
    @return bool Whether permalink links are enabled and index.php is in the URL.
    '''
    if Php.empty( self, 'permalink_structure' ):
      return False

    # If the index is not in the permalink, we're using mod_rewrite.
    return Php.preg_match( '#^/*' + self.index + '#', self.permalink_structure )

  def using_mod_rewrite_permalinks(self):
    ''' Determines whether permalinks are being used and rewrite module is enabled.
    Using permalinks and index.php is not in the URL.
    @access public
    @return bool Whether permalink links are enabled and index.php is NOT in the URL.
    '''
    return self.using_permalinks() and not self.using_index_permalinks()


  def preg_index(self, number):
    ''' Indexes for matches for usage in preg_*() functions.
    The format of the string is, with empty matches property value, 'NUM'.
    The 'NUM' will be replaced with the value in the number parameter. With
    the matches property not empty, the value of the returned string will
    contain that value of the matches property. The format then will be
    'MATCHES[NUM]', with MATCHES as the value in the property and NUM the
    value of the number parameter.
    @access public
    @param int number Index number.
    @return string
    '''
    match_prefix = '$'
    match_suffix = ''

    if not Php.empty(self, 'matches'):
      match_prefix = '$' + self.matches + '['
      match_suffix = ']'

    return match_prefix + number + match_suffix


  """
  def page_uri_index(self):
    ''' Retrieves all page and attachments for pages URIs.
    The attachments are for those that have pages as parents and will be
    retrieved.
    @access public
    @global wpdb $wpdb WordPress database abstraction object.
    @return array Array of page URIs as first element and attachment URIs as second element.
    '''
    wpdb = WpC.WB.Wj.wpdb  # global wpdb

    # Get pages in order of hierarchy, i.e. children after parents.
    $pages = $wpdb.get_results("SELECT ID, post_name, post_parent FROM $wpdb.posts WHERE post_type = 'page' AND post_status != 'auto-draft'")
    $posts = get_page_hierarchy( $pages )

    # If we have no pages get out quick.
    if !$posts:
      return array( array(), array() )

    # Now reverse it, because we need parents after children for rewrite rules to work properly.
    $posts = array_reverse($posts, True)

    $page_uris = array()
    $page_attachment_uris = array()

    for id, post in posts.items():
      # URL => page name
      $uri = get_page_uri($id)
      $attachments = $wpdb.get_results( $wpdb.prepare( "SELECT ID, post_name, post_parent FROM $wpdb.posts WHERE post_type = 'attachment' AND post_parent = %d", $id ))
      if !Php.empty($attachments):
        for attachment in $attachments:
          $attach_uri = get_page_uri($attachment.ID)
          $page_attachment_uris[$attach_uri] = $attachment.ID

      $page_uris[$uri] = $id

    return array( $page_uris, $page_attachment_uris )


  def page_rewrite_rules(self):
    ''' Retrieves all of the rewrite rules for pages.
    @access public
    @return array Page rewrite rules.
    '''
    # The extra .? at the beginning prevents clashes with other regular expressions in the rules array.
    self.add_rewrite_tag( '%pagename%', '(.?.+?)', 'pagename=' )

    return self.generate_rewrite_rules( self.get_page_permastruct(), EP_PAGES, True, True, False, False )


  def get_date_permastruct(self):
    ''' Retrieves date permalink structure, with year, month, and day.
    The permalink structure for the date, if not set already depends on the
    permalink structure. It can be one of three formats. The first is year,
    month, day; the second is day, month, year; and the last format is month,
    day, year. These are matched against the permalink structure for which
    one is used. If none matches, then the default will be used, which is
    year, month, day.
    Prevents post ID and date permalinks from overlapping. In the case of
    post_id, the date permalink will be prepended with front permalink with
    'date/' before the actual permalink to form the complete date permalink
    structure.
    @access public
    @return string|False False on no permalink structure. Date permalink structure.
    '''
    if Php.isset(self, 'date_structure'):
      return self.date_structure

    if Php.empty(self.permalink_structure):
      self.date_structure = ''
      return False

    # The date permalink must have year, month, and day separated by slashes.
    $endians = array('%year%/%monthnum%/%day%', '%day%/%monthnum%/%year%', '%monthnum%/%day%/%year%')

    self.date_structure = ''
    $date_endian = ''

    for endian in endians:
      if endian in this.permalink_structure:
        $date_endian= $endian
        break

    if Php.empty($date_endian):
      $date_endian = '%year%/%monthnum%/%day%'

    # Do not allow the date tags and %post_id% to overlap in the permalink
    # structure. If they do, move the date tags to $front/date/.
    $front = self.front
    preg_match_all('/%.+?%/', self.permalink_structure, $tokens)
    $tok_index = 1
    for token in Php.Array($tokens[0]):
      if '%post_id%' == $token and ($tok_index <= 3):
        $front = $front + 'date/'
        break
      $tok_index++

    self.date_structure = $front + $date_endian

    return self.date_structure


  def get_year_permastruct(self):
    ''' Retrieves the year permalink structure without month and day.
    Gets the date permalink structure and strips out the month and day
    permalink structures.
    @access public
    @return False|string False on failure. Year structure on success.
    '''
    $structure = self.get_date_permastruct()

    if Php.empty($structure):
      return False

    $structure = str_replace('%monthnum%', '', $structure)
    $structure = str_replace('%day%', '', $structure)
    $structure = preg_replace('#/+#', '/', $structure)

    return $structure


  def get_month_permastruct(self):
    ''' Retrieves the month permalink structure without day and with year.
    Gets the date permalink structure and strips out the day permalink
    structures. Keeps the year permalink structure.
    @access public
    @return False|string False on failure. Year/Month structure on success.
    '''
    $structure = self.get_date_permastruct()

    if Php.empty($structure):
      return False

    $structure = str_replace('%day%', '', $structure)
    $structure = preg_replace('#/+#', '/', $structure)

    return $structure


  def get_day_permastruct(self):
    ''' Retrieves the day permalink structure with month and year.
    Keeps date permalink structure with all year, month, and day.
    @access public
    @return string|False False on failure. Year/Month/Day structure on success.
    '''
    return self.get_date_permastruct()


  def get_category_permastruct(self):
    ''' Retrieves the permalink structure for categories.
    If the category_base property has no value, then the category structure
    will have the front property value, followed by 'category', and finally
    '%category%'. If it does, then the root property will be used, along with
    the category_base property value.
    @access public
    @return string|False False on failure. Category permalink structure.
    '''
    return self.get_extra_permastruct('category')


  def get_tag_permastruct(self):
    ''' Retrieve the permalink structure for tags.
    If the tag_base property has no value, then the tag structure will have
    the front property value, followed by 'tag', and finally '%tag%'. If it
    does, then the root property will be used, along with the tag_base
    property value.
    @access public
    @return string|False False on failure. Tag permalink structure.
    '''
    return self.get_extra_permastruct('post_tag')


  """
  def get_extra_permastruct(self, name):
    ''' Retrieves an extra permalink structure by name.
    @access public
    @param string $name Permalink structure name.
    @return string|False False if not found. Permalink structure string.
    '''
    if Php.empty(self.permalink_structure):
      return False

    if Php.isset(self.extra_permastructs, name):
      return self.extra_permastructs[name]['struct']

    return False

  """

  def get_author_permastruct(self):
    ''' Retrieves the author permalink structure.
    The permalink structure is front property, author base, and finally
    '/%author%'. Will set the author_structure property and then return it
    without attempting to set the value again.
    @access public
    @return string|False False if not found. Permalink structure string.
    '''
    if Php.isset(self, 'author_structure'):
      return self.author_structure

    if Php.empty(self.permalink_structure):
      self.author_structure = ''
      return False

    self.author_structure = self.front + self.author_base + '/%author%'

    return self.author_structure


  def get_search_permastruct(self):
    ''' Retrieves the search permalink structure.
    The permalink structure is root property, search base, and finally
    '/%search%'. Will set the search_structure property and then return it
    without attempting to set the value again.
    @access public
    @return string|False False if not found. Permalink structure string.
    '''
    if Php.isset(self, 'search_structure'):
      return self.search_structure

    if Php.empty(self.permalink_structure):
      self.search_structure = ''
      return False

    self.search_structure = self.root + self.search_base + '/%search%'

    return self.search_structure


  def get_page_permastruct(self):
    ''' Retrieves the page permalink structure.
    The permalink structure is root property, and '%pagename%'. Will set the
    page_structure property and then return it without attempting to set the
    value again.
    @access public
    @return string|False False if not found. Permalink structure string.
    '''
    if Php.isset(self, 'page_structure'):
      return self.page_structure

    if Php.empty(self.permalink_structure:
      self.page_structure = ''
      return False

    self.page_structure = self.root + '%pagename%'

    return self.page_structure


  def get_feed_permastruct(self):
    ''' Retrieves the feed permalink structure.
    The permalink structure is root property, feed base, and finally
    '/%feed%'. Will set the feed_structure property and then return it
    without attempting to set the value again.
    @access public
    @return string|False False if not found. Permalink structure string.
    '''
    if Php.isset(self, 'feed_structure'):
      return self.feed_structure

    if Php.empty(self.permalink_structure):
      self.feed_structure = ''
      return False

    self.feed_structure = self.root + self.feed_base + '/%feed%'

    return self.feed_structure


  def get_comment_feed_permastruct(self):
    ''' Retrieves the comment feed permalink structure.
    The permalink structure is root property, comment base property, feed
    base and finally '/%feed%'. Will set the comment_feed_structure property
    and then return it without attempting to set the value again.
    @access public
    @return string|False False if not found. Permalink structure string.
    '''
    if Php.isset(self, 'comment_feed_structure'):
      return self.comment_feed_structure

    if Php.empty(self.permalink_structure:
      self.comment_feed_structure = ''
      return False

    self.comment_feed_structure = self.root + self.comments_base + '/' + self.feed_base + '/%feed%'

    return self.comment_feed_structure


  def add_rewrite_tag(self, $tag, $regex, $query ):
    ''' Adds or updates existing rewrite tags (e.g. %postname%).
    If the tag already exists, replace the existing pattern and query for
    that tag, otherwise add the new tag.
    @access public
    @see WP_Rewrite::$rewritecode
    @see WP_Rewrite::$rewritereplace
    @see WP_Rewrite::$queryreplace
    @param string $tag   Name of the rewrite tag to add or update.
    @param string $regex Regular expression to substitute the tag for in rewrite rules.
    @param string $query String to append to the rewritten query. Must end in '='.
    '''
    $position = array_search( $tag, self.rewritecode )
    if False is not $position and None is not $position:
      self.rewritereplace[ $position ] = $regex
      self.queryreplace[ $position ] = $query
    else:
      self.rewritecode[None] = $tag
      self.rewritereplace[None] = $regex
      self.queryreplace[None] = $query


  def remove_rewrite_tag(self, $tag ):
    ''' Removes an existing rewrite tag.
    @access public
    @see WP_Rewrite::$rewritecode
    @see WP_Rewrite::$rewritereplace
    @see WP_Rewrite::$queryreplace
    @param string $tag Name of the rewrite tag to remove.
    '''
    $position = array_search( $tag, self.rewritecode )
    if False is not $position and None is not $position:
      unset( self.rewritecode[ $position ] )
      unset( self.rewritereplace[ $position ] )
      unset( self.queryreplace[ $position ] )


  def generate_rewrite_rules(self,$permalink_structure, $ep_mask = EP_NONE, $paged = True, $feed = True, $forcomments = False, $walk_dirs = True, $endpoints = True):
    ''' Generates rewrite rules from a permalink structure.
    The main WP_Rewrite function for building the rewrite rule list. The
    contents of the function is a mix of black magic and regular expressions,
    so best just ignore the contents and move to the parameters.
    @access public
    @param string $permalink_structure The permalink structure.
    @param int    $ep_mask             Optional. Endpoint mask defining what endpoints are added to the structure.
                                       Accepts `EP_NONE`, `EP_PERMALINK`, `EP_ATTACHMENT`, `EP_DATE`, `EP_YEAR`,
                                       `EP_MONTH`, `EP_DAY`, `EP_ROOT`, `EP_COMMENTS`, `EP_SEARCH`, `EP_CATEGORIES`,
                                       `EP_TAGS`, `EP_AUTHORS`, `EP_PAGES`, `EP_ALL_ARCHIVES`, and `EP_ALL`.
                                       Default `EP_NONE`.
    @param bool   $paged               Optional. Whether archive pagination rules should be added for the structure.
                                       Default True.
    @param bool   $feed                Optional Whether feed rewrite rules should be added for the structure.
                                       Default True.
    @param bool   $forcomments         Optional. Whether the feed rules should be a query for a comments feed.
                                       Default False.
    @param bool   $walk_dirs           Optional. Whether the 'directories' making up the structure should be walked
                                       over and rewrite rules built for each in-turn. Default True.
    @param bool   $endpoints           Optional. Whether endpoints should be applied to the generated rewrite rules.
                                       Default True.
    @return array Rewrite rule list.
    '''
    # Build a regex to match the feed section of URLs, something like (feed|atom|rss|rss2)/?
    $feedregex2 = ''
    for feed_name in Php.Array( self.feeds):
      $feedregex2 += $feed_name + '|'
    $feedregex2 = '(' + trim($feedregex2, '|') + ')/?$'

    # $feedregex is identical but with /feed/ added on as well, so URLs like <permalink>/feed/atom
    # and <permalink>/atom are both possible
    $feedregex = self.feed_base + '/' + $feedregex2

    # Build a regex to match the trackback and page/xx parts of URLs.
    $trackbackregex = 'trackback/?$'
    $pageregex = self.pagination_base + '/?([0-9]{1,})/?$'
    $commentregex = self.comments_pagination_base + '-([0-9]{1,})/?$'
    $embedregex = 'embed/?$'

    # Build up an array of endpoint regexes to append => queries to append.
    if $endpoints:
      $ep_query_append = array()
      for endpoint in Php.Array( self.endpoints):
        # Match everything after the endpoint name, but allow for nothing to appear there.
        $epmatch = $endpoint[1] + '(/(.*))?/?$'

        # This will be appended on to the rest of the query for each dir.
        $epquery = '&' + $endpoint[2] + '='
        $ep_query_append[$epmatch] = array( $endpoint[0], $epquery )

    # Get everything up to the first rewrite tag.
    $front = Php.substr($permalink_structure, 0, Php.strpos($permalink_structure, '%'))

    # Build an array of the tags (note that said array ends up being in $tokens[0]).
    preg_match_all('/%.+?%/', $permalink_structure, $tokens)

    $num_tokens = count($tokens[0])

    $index = self.index; #probably 'index.php'
    $feedindex = $index
    $trackbackindex = $index
    $embedindex = $index

    # Build a list from the rewritecode and queryreplace arrays, that will look something
    # like tagname=$matches[i] where i is the current $i.
    $queries = array()
    for ( $i = 0; $i < $num_tokens; ++$i ) {
      if 0 < $i:
        $queries[$i] = $queries[$i - 1] + '&'
      else:
        $queries[$i] = ''

      $query_token = str_replace(self.rewritecode, self.queryreplace, $tokens[0][$i]) + self.preg_index($i+1)
      $queries[$i] += $query_token

    # Get the structure, minus any cruft (stuff that isn't tags) at the front.
    $structure = $permalink_structure
    if $front != '/':
      $structure = str_replace($front, '', $structure)

    # Create a list of dirs to walk over, making rewrite rules for each level
    # so for example, a $structure of /%year%/%monthnum%/%postname% would create
    # rewrite rules for /%year%/, /%year%/%monthnum%/ and /%year%/%monthnum%/%postname%
    $structure = trim($structure, '/')
    $dirs = $walk_dirs ? explode('/', $structure) : array( $structure )
    $num_dirs = count($dirs)

    # Strip slashes from the front of $front.
    $front = preg_replace('|^/+|', '', $front)

    # The main workhorse loop.
    $post_rewrite = array()
    $struct = $front
    for ( $j = 0; $j < $num_dirs; ++$j ) {
      # Get the struct for this dir, and trim slashes off the front.
      $struct += $dirs[$j] + '/'; # Accumulate. see comment near explode('/', $structure) above.
      $struct = ltrim($struct, '/')

      # Replace tags with regexes.
      $match = str_replace(self.rewritecode, self.rewritereplace, $struct)

      # Make a list of tags, and store how many there are in $num_toks.
      $num_toks = preg_match_all('/%.+?%/', $struct, $toks)

      # Get the 'tagname=$matches[i]'.
      $query = ( ! Php.empty( $num_toks ) and Php.isset(queries, $num_toks - 1) ) ? $queries[$num_toks - 1] : ''

      # Set up $ep_mask_specific which is used to match more specific URL types.
      switch ( $dirs[$j] ) {
        case '%year%':
          $ep_mask_specific = EP_YEAR
          break
        case '%monthnum%':
          $ep_mask_specific = EP_MONTH
          break
        case '%day%':
          $ep_mask_specific = EP_DAY
          break
        default:
          $ep_mask_specific = EP_NONE

      # Create query for /page/xx.
      $pagematch = $match + $pageregex
      $pagequery = $index + '?' + $query + '&paged=' + self.preg_index($num_toks + 1)

      # Create query for /comment-page-xx.
      $commentmatch = $match + $commentregex
      $commentquery = $index + '?' + $query + '&cpage=' + self.preg_index($num_toks + 1)

      if WiO.get_option('page_on_front'):
        # Create query for Root /comment-page-xx.
        $rootcommentmatch = $match + $commentregex
        $rootcommentquery = $index + '?' + $query + '&page_id=' + WiO.get_option('page_on_front') + '&cpage=' + self.preg_index($num_toks + 1)

      # Create query for /feed/(feed|atom|rss|rss2|rdf).
      $feedmatch = $match + $feedregex
      $feedquery = $feedindex + '?' + $query + '&feed=' + self.preg_index($num_toks + 1)

      # Create query for /(feed|atom|rss|rss2|rdf) (see comment near creation of $feedregex).
      $feedmatch2 = $match + $feedregex2
      $feedquery2 = $feedindex + '?' + $query + '&feed=' + self.preg_index($num_toks + 1)

      # Create query and regex for embeds.
      $embedmatch = $match + $embedregex
      $embedquery = $embedindex + '?' + $query + '&embed=true'

      # If asked to, turn the feed queries into comment feed ones.
      if $forcomments:
        $feedquery += '&withcomments=1'
        $feedquery2 += '&withcomments=1'

      # Start creating the array of rewrites for this dir.
      $rewrite = array()

      # ...adding on /feed/ regexes => queries
      if $feed:
        $rewrite = array( ($feedmatch,  $feedquery ),
                          ($feedmatch2, $feedquery2),
                          ($embedmatch, $embedquery), )

      #...and /page/xx ones
      if $paged:
        $rewrite = array_merge( $rewrite, array( ($pagematch, $pagequery) ))

      # Only on pages with comments add ../comment-page-xx/.
      if EP_PAGES & $ep_mask or EP_PERMALINK & $ep_mask:
        $rewrite = array_merge($rewrite, array( (commentmatch, $commentquery) ) )
      elif EP_ROOT & $ep_mask and WiO.get_option('page_on_front'):
        $rewrite = array_merge($rewrite, array($rootcommentmatch, $rootcommentquery))

      # Do endpoints.
      if $endpoints:
        for regex, ep in Php.Array( $ep_query_append).items():
          # Add the endpoints on if the mask fits.
          if $ep[0] & $ep_mask or $ep[0] & $ep_mask_specific:
            $rewrite[$match + $regex] = $index + '?' + $query + $ep[1] + self.preg_index($num_toks + 2)

      # If we've got some tags in this dir.
      if $num_toks:
        $post = False
        $page = False

        # Check to see if this dir is permalink-level: i.e. the structure specifies an
        # individual post. Do this by checking it contains at least one of 1) post name,
        # 2) post ID, 3) page name, 4) timestamp (year, month, day, hour, second and
        # minute all present). Set these flags now as we need them for the endpoints.
        if ( '%postname%' in struct or '%post_id%' in struct
            or '%pagename%' in struct
            or ('%year%' in struct and '%monthnum%' in struct and
                '%day%' in struct and '%hour%' in struct and
                '%minute%' in struct and '%second%' in struct)
            ):
          $post = True
          if '%pagename%' in struct:
            $page = True

        if ! $post:
          # For custom post types, we need to add on endpoints as well.
          for ptype in get_post_types( array( ('_builtin', False) ) ):
            if "%$ptype%" in struct:
              $post = True

              # This is for page style attachment URLs.
              $page = is_post_type_hierarchical( $ptype )
              break

        # If creating rules for a permalink, do all the endpoints like attachments etc.
        if $post:
          # Create query and regex for trackback.
          $trackbackmatch = $match + $trackbackregex
          $trackbackquery = $trackbackindex + '?' + $query + '&tb=1'

          # Create query and regex for embeds.
          $embedmatch = $match + $embedregex
          $embedquery = $embedindex + '?' + $query + '&embed=true'

          # Trim slashes from the end of the regex for this dir.
          $match = rtrim($match, '/')

          # Get rid of brackets.
          $submatchbase = str_replace( array('(', ')'), '', $match)

          # Add a rule for at attachments, which take the form of <permalink>/some-text.
          $sub1 = $submatchbase + '/([^/]+)/'

          # Add trackback regex <permalink>/trackback/...
          $sub1tb = $sub1 + $trackbackregex

          # And <permalink>/feed/(atom|...)
          $sub1feed = $sub1 + $feedregex

          # And <permalink>/(feed|atom...)
          $sub1feed2 = $sub1 + $feedregex2

          # And <permalink>/comment-page-xx
          $sub1comment = $sub1 + $commentregex

          # And <permalink>/embed/...
          $sub1embed = $sub1 + $embedregex

          # Add another rule to match attachments in the explicit form:
          # <permalink>/attachment/some-text
          $sub2 = $submatchbase + '/attachment/([^/]+)/'

          # And add trackbacks <permalink>/attachment/trackback.
          $sub2tb = $sub2 + $trackbackregex

          # Feeds, <permalink>/attachment/feed/(atom|...)
          $sub2feed = $sub2 + $feedregex

          # And feeds again on to this <permalink>/attachment/(feed|atom...)
          $sub2feed2 = $sub2 + $feedregex2

          # And <permalink>/comment-page-xx
          $sub2comment = $sub2 + $commentregex

          # And <permalink>/embed/...
          $sub2embed = $sub2 + $embedregex

          # Create queries for these extra tag-ons we've just dealt with.
          $subquery = $index + '?attachment=' + self.preg_index(1)
          $subtbquery = $subquery + '&tb=1'
          $subfeedquery = $subquery + '&feed=' + self.preg_index(2)
          $subcommentquery = $subquery + '&cpage=' + self.preg_index(2)
          $subembedquery = $subquery + '&embed=true'

          # Do endpoints for attachments.
          if !Php.empty($endpoints):
            for regex, ep in Php.Array( $ep_query_append).items():
              if $ep[0] & EP_ATTACHMENT:
                $rewrite[$sub1 + $regex] = $subquery + $ep[1] + self.preg_index(3)
                $rewrite[$sub2 + $regex] = $subquery + $ep[1] + self.preg_index(3)

          # Now we've finished with endpoints, finish off the $sub1 and $sub2 matches
          # add a ? as we don't have to match that last slash, and finally a $ so we
          # match to the end of the URL
          $sub1 += '?$'
          $sub2 += '?$'

          # Post pagination, e.g. <permalink>/2/
          # Previously: '(/[0-9]+)?/?$', which produced '/2' for page.
          # When cast to int, returned 0.
          $match = $match + '(?:/([0-9]+))?/?$'
          $query = $index + '?' + $query + '&page=' + self.preg_index($num_toks + 1)

        # Not matching a permalink so this is a lot simpler.
        else:
          # Close the match and finalise the query.
          $match += '?$'
          $query = $index + '?' + $query

        # Create the final array for this dir by joining the $rewrite array (which currently
        # only contains rules/queries for trackback, pages etc) to the main regex/query for
        # this dir
        $rewrite = array_merge($rewrite, array( (match, query) ))

        # If we're matching a permalink, add those extras (attachments etc) on.
        if $post:
          # Add trackback.
          $rewrite = array_merge(array( (trackbackmatch, trackbackquery) ), $rewrite)

          # Add embed.
          $rewrite = array_merge( array( (embedmatch, embedquery) ), $rewrite )

          # Add regexes/queries for attachments, attachment trackbacks and so on.
          if ! $page:
            # Require <permalink>/attachment/stuff form for pages because of confusion with subpages.
            $rewrite = array_merge( $rewrite, array(
              (sub1       , subquery),
              (sub1tb     , subtbquery),
              (sub1feed   , subfeedquery),
              (sub1feed2  , subfeedquery),
              (sub1comment, subcommentquery),
              (sub1embed  , subembedquery),
            ) )

          $rewrite = array_merge( array(
              (sub2       , subquery),
              (sub2tb     , subtbquery),
              (sub2feed   , subfeedquery),
              (sub2feed2  , subfeedquery),
              (sub2comment, subcommentquery),
              (sub2embed  , subembedquery),
            ), $rewrite )
      # Add the rules for this dir to the accumulating $post_rewrite.
      $post_rewrite = array_merge($rewrite, $post_rewrite)

    # The finished rules. phew!
    return $post_rewrite


  def generate_rewrite_rule(self, $permalink_structure, $walk_dirs = False):
    ''' Generates rewrite rules with permalink structure and walking directory only.
    Shorten version of WP_Rewrite::generate_rewrite_rules() that allows for shorter
    list of parameters. See the method for longer description of what generating
    rewrite rules does.
    @access public
    @see WP_Rewrite::generate_rewrite_rules() See for long description and rest of parameters.
    @param string $permalink_structure The permalink structure to generate rules.
    @param bool   $walk_dirs           Optional, default is False. Whether to create list of directories to walk over.
    @return array
    '''
    return self.generate_rewrite_rules($permalink_structure, EP_NONE, False, False, False, $walk_dirs)


  def rewrite_rules(self):
    ''' Constructs rewrite matches and queries from permalink structure.
    Runs the action {@see 'generate_rewrite_rules'} with the parameter that is an
    reference to the current WP_Rewrite instance to further manipulate the
    permalink structures and rewrite rules. Runs the {@see 'rewrite_rules_array'}
    filter on the full rewrite rule array.
    There are two ways to manipulate the rewrite rules, one by hooking into
    the {@see 'generate_rewrite_rules'} action and gaining full control of the
    object or just manipulating the rewrite rule array before it is passed
    from the function.
    @access public
    @return array An associate array of matches and queries.
    '''
    $rewrite = array()

    if Php.empty(self.permalink_structure):
      return $rewrite

    # robots.txt -only if installed at the root
    $home_path = parse_url( home_url() )
    $robots_rewrite = ( Php.empty( $home_path['path'] ) or '/' == $home_path['path'] ) ? array( ('robots\.txt$', self.index + '?robots=1') ) : array()

    # Old feed and service files.
    $deprecated_files = array(
      ( '.*wp-(atom|rdf|rss|rss2|feed|commentsrss2)\.php$', self.index + '?feed=old'),
      ( '.*wp-app\.php(/.*)?$', self.index + '?error=403'),
    )

    # Registration rules.
    $registration_pages = array()
    if WpC.WB.Wj.is_multisite() and is_main_site():
      $registration_pages['.*wp-signup.php$'] = self.index + '?signup=true'
      $registration_pages['.*wp-activate.php$'] = self.index + '?activate=true'

    # Deprecated.
    $registration_pages['.*wp-register.php$'] = self.index + '?register=true'

    # Post rewrite rules.
    $post_rewrite = self.generate_rewrite_rules( self.permalink_structure, EP_PERMALINK )

    # Filters rewrite rules used for "post" archives.
    # @param array $post_rewrite The rewrite rules for posts.
    $post_rewrite = apply_filters( 'post_rewrite_rules', $post_rewrite )

    # Date rewrite rules.
    $date_rewrite = self.generate_rewrite_rules(self.get_date_permastruct(), EP_DATE)

    # Filters rewrite rules used for date archives.
    # Likely date archives would include /yyyy/, /yyyy/mm/, and /yyyy/mm/dd/.
    # @param array $date_rewrite The rewrite rules for date archives.
    $date_rewrite = apply_filters( 'date_rewrite_rules', $date_rewrite )

    # Root-level rewrite rules.
    $root_rewrite = self.generate_rewrite_rules(self.root + '/', EP_ROOT)

    # Filters rewrite rules used for root-level archives.
    # Likely root-level archives would include pagination rules for the homepage
    # as well as site-wide post feeds (e.g. /feed/, and /feed/atom/).
    # @param array $root_rewrite The root-level rewrite rules.
    $root_rewrite = apply_filters( 'root_rewrite_rules', $root_rewrite )

    # Comments rewrite rules.
    $comments_rewrite = self.generate_rewrite_rules(self.root + self.comments_base, EP_COMMENTS, False, True, True, False)

    # Filters rewrite rules used for comment feed archives.
    # Likely comments feed archives include /comments/feed/, and /comments/feed/atom/.
    # @param array $comments_rewrite The rewrite rules for the site-wide comments feeds.
    $comments_rewrite = apply_filters( 'comments_rewrite_rules', $comments_rewrite )

    # Search rewrite rules.
    $search_structure = self.get_search_permastruct()
    $search_rewrite = self.generate_rewrite_rules($search_structure, EP_SEARCH)

    # Filters rewrite rules used for search archives.
    # Likely search-related archives include /search/search+query/ as well as
    # pagination and feed paths for a search.
    # @param array $search_rewrite The rewrite rules for search queries.
    $search_rewrite = apply_filters( 'search_rewrite_rules', $search_rewrite )

    # Author rewrite rules.
    $author_rewrite = self.generate_rewrite_rules(self.get_author_permastruct(), EP_AUTHORS)

    # Filters rewrite rules used for author archives.
    # Likely author archives would include /author/author-name/, as well as
    # pagination and feed paths for author archives.
    # @param array $author_rewrite The rewrite rules for author archives.
    $author_rewrite = apply_filters( 'author_rewrite_rules', $author_rewrite )

    # Pages rewrite rules.
    $page_rewrite = self.page_rewrite_rules()

    # Filters rewrite rules used for "page" post type archives.
    # @param array $page_rewrite The rewrite rules for the "page" post type.
    $page_rewrite = apply_filters( 'page_rewrite_rules', $page_rewrite )

    # Extra permastructs.
    for permastructname, struct in self.extra_permastructs.items():
      if is_array( $struct ):
        if count( $struct ) == 2:
          $rules = self.generate_rewrite_rules( $struct[0], $struct[1] )
        else:
          $rules = self.generate_rewrite_rules( $struct['struct'], $struct['ep_mask'], $struct['paged'], $struct['feed'], $struct['forcomments'], $struct['walk_dirs'], $struct['endpoints'] )
      else:
        $rules = self.generate_rewrite_rules( $struct )

      # Filters rewrite rules used for individual permastructs.
      # The dynamic portion of the hook name, `$permastructname`, refers
      # to the name of the registered permastruct, e.g. 'post_tag' (tags),
      # 'category' (categories), etc.
      # @param array $rules The rewrite rules generated for the current permastruct.
      $rules = apply_filters( permastructname + '_rewrite_rules', $rules )
      if 'post_tag' == $permastructname:

        # Filters rewrite rules used specifically for Tags.
        # @deprecated 3.1.0 Use 'post_tag_rewrite_rules' instead
        # @param array $rules The rewrite rules generated for tags.
        $rules = apply_filters( 'tag_rewrite_rules', $rules )

      self.extra_rules_top = array_merge(self.extra_rules_top, $rules)

    # Put them together.
    if self.use_verbose_page_rules:
      self.rules = array_merge(self.extra_rules_top, $robots_rewrite, $deprecated_files, $registration_pages, $root_rewrite, $comments_rewrite, $search_rewrite,  $author_rewrite, $date_rewrite, $page_rewrite, $post_rewrite, self.extra_rules)
    else:
      self.rules = array_merge(self.extra_rules_top, $robots_rewrite, $deprecated_files, $registration_pages, $root_rewrite, $comments_rewrite, $search_rewrite,  $author_rewrite, $date_rewrite, $post_rewrite, $page_rewrite, self.extra_rules)

    # Fires after the rewrite rules are generated.
    # @param WP_Rewrite self Current WP_Rewrite instance, passed by reference.
    do_action_ref_array( 'generate_rewrite_rules', array( self ) ) # &this

    # Filters the full set of generated rewrite rules.
    # @param array self.rules The compiled array of rewrite rules.
    self.rules = apply_filters( 'rewrite_rules_array', self.rules )

    return self.rules


  def wp_rewrite_rules(self):
    ''' Retrieves the rewrite rules.
    The difference between this method and WP_Rewrite::rewrite_rules() is that
    this method stores the rewrite rules in the 'rewrite_rules' option and retrieves
    it. This prevents having to process all of the permalinks to get the rewrite rules
    in the form of caching.
    @access public
    @return array Rewrite rules.
    '''
    self.rules = WiO.get_option('rewrite_rules')
    if Php.empty(self.rules):
      self.matches = 'matches'
      self.rewrite_rules()
      if not WiPg.did_action( 'wp_loaded' ):
      	WiPg.add_action( 'wp_loaded', array( $this, 'flush_rules' ) )
      	return self.rules
      update_option('rewrite_rules', self.rules)

    return self.rules


  def mod_rewrite_rules(self):
    ''' Retrieves mod_rewrite-formatted rewrite rules to write to .htaccess.
    Does not actually write to the .htaccess file, but creates the rules for
    the process that will.
    Will add the non_wp_rules property rules to the .htaccess file before
    the WordPress rewrite rules one.
    @access public
    @return string
    '''
    if ! self.using_permalinks():
      return ''

    $site_root = parse_url( site_url() )
    if Php.isset( site_root, 'path' ):
      $site_root = trailingslashit($site_root['path'])

    $home_root = parse_url(home_url())
    if Php.isset( home_root, 'path' ):
      $home_root = trailingslashit($home_root['path'])
    else:
      $home_root = '/'

    $rules = "<IfModule mod_rewrite.c>\n"
    $rules += "RewriteEngine On\n"
    $rules += "RewriteBase $home_root\n"

    # Prevent -f checks on index.php.
    $rules += "RewriteRule ^index\.php$ - [L]\n"

    # Add in the rules that don't redirect to WP's index.php (and thus shouldn't be handled by WP at all).
    for match, query in Php.Array( self.non_wp_rules).items():
      # Apache 1.3 does not support the reluctant (non-greedy) modifier.
      $match = str_replace('.+?', '.+', $match)

      $rules += 'RewriteRule ^' + $match + ' ' + $home_root + $query + " [QSA,L]\n"

    if self.use_verbose_rules:
      self.matches = ''
      $rewrite = self.rewrite_rules()
      $num_rules = count($rewrite)
      $rules += "RewriteCond %{REQUEST_FILENAME} -f [OR]\n" +
        "RewriteCond %{REQUEST_FILENAME} -d\n" +
        "RewriteRule ^.*$ - [S=$num_rules]\n"

      for match, query in Php.Array( $rewrite).items():
        # Apache 1.3 does not support the reluctant (non-greedy) modifier.
        $match = str_replace('.+?', '.+', $match)

        if self.index in query:
          $rules += 'RewriteRule ^' + $match + ' ' + $home_root + $query + " [QSA,L]\n"
        else:
          $rules += 'RewriteRule ^' + $match + ' ' + $site_root + $query + " [QSA,L]\n"

    else:
      $rules += "RewriteCond %{REQUEST_FILENAME} !-f\n" +
        "RewriteCond %{REQUEST_FILENAME} !-d\n" +
        "RewriteRule + {}{} [L]\n".format(home_root, self.index)

    $rules += "</IfModule>\n"

    # Filters the list of rewrite rules formatted for output to an .htaccess file.
    # @param string $rules mod_rewrite Rewrite rules formatted for .htaccess.
    $rules = apply_filters( 'mod_rewrite_rules', $rules )

    # Filters the list of rewrite rules formatted for output to an .htaccess file.
    # @deprecated 1.5.0 Use the mod_rewrite_rules filter instead.
    # @param string $rules mod_rewrite Rewrite rules formatted for .htaccess.
    return apply_filters( 'rewrite_rules', $rules )


  def iis7_url_rewrite_rules(self, $add_parent_tags = False ):
    ''' Retrieves IIS7 URL Rewrite formatted rewrite rules to write to web.config file.
    Does not actually write to the web.config file, but creates the rules for
    the process that will.
    @access public
    @param bool $add_parent_tags Optional. Whether to add parent tags to the rewrite rule sets.
                                 Default False.
    @return string IIS7 URL rewrite rule sets.
    '''
    if ! self.using_permalinks():
      return ''
    $rules = ''
    if $add_parent_tags:
      $rules += '<configuration>
  <system.webServer>
    <rewrite>
      <rules>'

    $rules += '
      <rule name="WordPress: ' + esc_attr( home_url() ) + '" patternSyntax="Wildcard">
        <match url="*" />
          <conditions>
            <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
            <add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" />
          </conditions>
        <action type="Rewrite" url="index.php" />
      </rule>'

    if $add_parent_tags:
      $rules += '
      </rules>
    </rewrite>
  </system.webServer>
</configuration>'

    # Filters the list of rewrite rules formatted for output to a web.config.
    # @param string $rules Rewrite rules formatted for IIS web.config.
    return apply_filters( 'iis7_url_rewrite_rules', $rules )


  def add_rule(self, $regex, $query, $after = 'bottom' ):
    ''' Adds a rewrite rule that transforms a URL structure to a set of query vars.
    Any value in the $after parameter that isn't 'bottom' will result in the rule
    being placed at the top of the rewrite rules.
    @since 4.4.0 Array support was added to the `$query` parameter.
    @access public
    @param string       $regex Regular expression to match request against.
    @param string|array $query The corresponding query vars for this rewrite rule.
    @param string       $after Optional. Priority of the new rule. Accepts 'top'
                               or 'bottom'. Default 'bottom'.
    '''
    if is_array( $query ):
      $external = False
      $query = add_query_arg( $query, 'index.php' )
    else:
      #$index = False is strpos( $query, '?' ) ? strlen( $query ) : strpos( $query, '?' )
      $index = Php.strlen( $query ) if '?' not in query else Php.strpos( $query, '?' )
      $front = Php.substr( $query, 0, $index )

      $external = $front != self.index

    # "external" = it doesn't correspond to index.php.
    if $external:
      self.add_external_rule( $regex, $query )
    else:
      if 'bottom' == $after:
        self.extra_rules = array_merge( self.extra_rules, array( ($regex, $query)) )
      else:
        self.extra_rules_top = array_merge( self.extra_rules_top, array( (regex, query)) )


  def add_external_rule(self, $regex, $query ):
    ''' Adds a rewrite rule that doesn't correspond to index.php.
    @access public
    @param string $regex Regular expression to match request against.
    @param string $query The corresponding query vars for this rewrite rule.
    '''
    self.non_wp_rules[ $regex ] = $query


  def add_endpoint(self, $name, $places, $query_var = True, *OtherArgs ):
    ''' Adds an endpoint, like /trackback/.
    @since 3.9.0 $query_var parameter added.
    @since 4.3.0 Added support for skipping query var registration by passing `False` to `$query_var`.
    @access public
    @see add_rewrite_endpoint() for full documentation.
    @global WP $wp
    @param string      $name      Name of the endpoint.
    @param int         $places    Endpoint mask describing the places the endpoint should be added.
    @param string|bool $query_var Optional. Name of the corresponding query variable. Pass `False` to
                                  skip registering a query_var for this endpoint. Defaults to the
                                  value of `$name`.
    '''
    wp = WpC.WB.Wj.wp  # global wp
    AllArgs = name, places, query_var, *OtherArgs

    # For backward compatibility, if None has explicitly been passed as `$query_var`, assume `True`.
    if True is $query_var or None is Php.func_get_arg( AllArgs, 2 ):
      $query_var = $name
    self.endpoints[None] = array( $places, $name, $query_var )

    if $query_var:
      $wp.add_query_var( $query_var )


  def add_permastruct(self, $name, $struct, $args = array(), *OtherArgs ):
    ''' Adds a new permalink structure.
    A permalink structure (permastruct) is an abstract definition of a set of rewrite rules
    it is an easy way of expressing a set of regular expressions that rewrite to a set of
    query strings. The new permastruct is added to the WP_Rewrite::$extra_permastructs array.
    When the rewrite rules are built by WP_Rewrite::rewrite_rules(), all of these extra
    permastructs are passed to WP_Rewrite::generate_rewrite_rules() which transforms them
    into the regular expressions that many love to hate.
    The `$args` parameter gives you control over how WP_Rewrite::generate_rewrite_rules()
    works on the new permastruct.
    @access public
    @param string $name   Name for permalink structure.
    @param string $struct Permalink structure (e.g. category/%category%)
    @param array  $args   {
        Optional. Arguments for building rewrite rules based on the permalink structure.
        Default empty array.
        @type bool $with_front  Whether the structure should be prepended with `WP_Rewrite::$front`.
                                Default True.
        @type int  $ep_mask     The endpoint mask defining which endpoints are added to the structure.
                                Accepts `EP_NONE`, `EP_PERMALINK`, `EP_ATTACHMENT`, `EP_DATE`, `EP_YEAR`,
                                `EP_MONTH`, `EP_DAY`, `EP_ROOT`, `EP_COMMENTS`, `EP_SEARCH`, `EP_CATEGORIES`,
                                `EP_TAGS`, `EP_AUTHORS`, `EP_PAGES`, `EP_ALL_ARCHIVES`, and `EP_ALL`.
                                Default `EP_NONE`.
        @type bool $paged       Whether archive pagination rules should be added for the structure.
                                Default True.
        @type bool $feed        Whether feed rewrite rules should be added for the structure. Default True.
        @type bool $forcomments Whether the feed rules should be a query for a comments feed. Default False.
        @type bool $walk_dirs   Whether the 'directories' making up the structure should be walked over
                                and rewrite rules built for each in-turn. Default True.
        @type bool $endpoints   Whether endpoints should be applied to the generated rules. Default True.

    '''
    AllArgs = name, struct, args, *OtherArgs
    # Back-compat for the old parameters: $with_front and $ep_mask.
    if ! is_array( $args ):
      $args = array( ('with_front', args) )
    if Php.func_num_args(AllArgs) == 4:
      $args['ep_mask'] = Php.func_get_arg( AllArgs, 3 )

    $defaults = array(
      ('with_front' , True),
      ('ep_mask'    , EP_NONE),
      ('paged'      , True),
      ('feed'       , True),
      ('forcomments', False),
      ('walk_dirs'  , True),
      ('endpoints'  , True),
    )
    $args = array_intersect_key( $args, $defaults )
    $args = wp_parse_args( $args, $defaults )

    if $args['with_front']:
      $struct = self.front + $struct
    else:
      $struct = self.root + $struct
    $args['struct'] = $struct

    self.extra_permastructs[ $name ] = $args


  def remove_permastruct(self, $name ):
    ''' Removes a permalink structure.
    @access public
    @param string $name Name for permalink structure.
    '''
    unset( self.extra_permastructs[ $name ] )


  def flush_rules(self, $hard = True ):
    ''' Removes rewrite rules and then recreate rewrite rules.
    Calls WP_Rewrite::wp_rewrite_rules() after removing the 'rewrite_rules' option.
    If the function named 'save_mod_rewrite_rules' exists, it will be called.
    @access public
    @staticvar bool $do_hard_later
    @param bool $hard Whether to update .htaccess (hard flush) or just update rewrite_rules option (soft flush). Default is True (hard).
    '''
    static $do_hard_later = None

    # Prevent this action from running before everyone has registered their rewrites.
    if ! did_action( 'wp_loaded' ):
      #add_action( 'wp_loaded', array( self, 'flush_rules' ) )
      add_action(  'wp_loaded', self.flush_rules ) )
      $do_hard_later = ( Php.isset(locals(), do_hard_later ) ) ? $do_hard_later or $hard : $hard
      return

    if Php.isset(locals(), do_hard_later ):
      $hard = $do_hard_later
      unset( $do_hard_later )

    update_option( 'rewrite_rules', '' )
    self.wp_rewrite_rules()

    # Filters whether a "hard" rewrite rule flush should be performed when requested.
    # A "hard" flush updates .htaccess (Apache) or web.config (IIS).
    # @param bool $hard Whether to flush rewrite rules "hard". Default True.
    if ! $hard or ! apply_filters( 'flush_rewrite_rules_hard', True ):
      return

    if function_exists( 'save_mod_rewrite_rules' ):
      save_mod_rewrite_rules()
    if function_exists( 'iis7_save_url_rewrite_rules' ):
      iis7_save_url_rewrite_rules()
  """


  def init(self):
    ''' Sets up the object's properties.
    The 'use_verbose_page_rules' object property will be set to True if the
    permalink structure begins with one of the following: '%postname%', '%category%',
    '%tag%', or '%author%'.
    @access public
    '''
    self.extra_rules = self.non_wp_rules = self.endpoints = array()
    self.permalink_structure = WiO.get_option('permalink_structure')
    self.front = Php.substr(self.permalink_structure, 0, Php.strpos(self.permalink_structure, '%'))
    self.root = ''

    if self.using_index_permalinks():
      self.root = self.index + '/'

    try: del self.author_structure
    except: pass
    try: del self.date_structure
    except: pass
    try: del self.page_structure
    except: pass
    try: del self.search_structure
    except: pass
    try: del self.feed_structure
    except: pass
    try: del self.comment_feed_structure
    except: pass
    self.use_trailing_slashes = ( '/' == Php.substr(self.permalink_structure, -1, 1) )

    # Enable generic rules for pages if permalink structure doesn't begin with a wildcard.
    if Php.preg_match("/^[^%]*%(?:postname|category|tag|author)%/", self.permalink_structure):
       self.use_verbose_page_rules = True
    else:
      self.use_verbose_page_rules = False

  """
  def set_permalink_structure(self,$permalink_structure):
    ''' Sets the main permalink structure for the site.
    Will update the 'permalink_structure' option, if there is a difference
    between the current permalink structure and the parameter value. Calls
    WP_Rewrite::init() after the option is updated.
    Fires the {@see 'permalink_structure_changed'} action once the init call has
    processed passing the old and new values
    @access public
    @param string $permalink_structure Permalink structure.
    '''
    if $permalink_structure != self.permalink_structure:
      $old_permalink_structure = self.permalink_structure
      update_option('permalink_structure', $permalink_structure)

      self.init()

      # Fires after the permalink structure is updated.
      # @param string $old_permalink_structure The previous permalink structure.
      # @param string $permalink_structure     The new permalink structure.
      do_action( 'permalink_structure_changed', $old_permalink_structure, $permalink_structure )


  def set_category_base(self,$category_base):
    ''' Sets the category base for the category permalink.
    Will update the 'category_base' option, if there is a difference between
    the current category base and the parameter value. Calls WP_Rewrite::init()
    after the option is updated.
    @access public
    @param string $category_base Category permalink structure base.
    '''
    if $category_base != WiO.get_option('category_base'):
      update_option('category_base', $category_base)
      self.init()


  def set_tag_base(self, $tag_base ):
    ''' Sets the tag base for the tag permalink.
    Will update the 'tag_base' option, if there is a difference between the
    current tag base and the parameter value. Calls WP_Rewrite::init() after
    the option is updated.
    @access public
    @param string $tag_base Tag permalink structure base.
    '''
    if $tag_base != WiO.get_option( 'tag_base'):
      update_option( 'tag_base', $tag_base )
      self.init()

"""
